\chapter{La création des objets}

\section{Reconnaissance vocale : Application Android}
	\subsection{Etat de l’art}	
Tout projet implique une phase de recherche, afin d'effectuer un état de l'art sur ce qu'il a déjà été fait 
auparavant dans ce domaine. Afin de rechercher ce qu'il fallait pour cet état de l'art, il a donc fallu 
décomposer en plusieurs parties ce que devait réellement réaliser cette reconnaissance. Ces parties étaient :

\begin{itemize}
\item Activation de la reconnaissance vocale automatiquement
\item Gestion de la chaine de caractères comprise par la reconnaissance
\end{itemize}

De base sur Android, il est possible d'activer la reconnaissance vocale  automatiquement grâce aux mots clefs 
« OK Google ». Souhaitant appeler notre intelligence domotique Jarvis, il était peu souhaitable de dire ces 
mots afin d'activer la reconnaissance.
Après recherches, il s'avère qu'il n'existe aucun moyen simple de changer ces mots clefs, puisque les seuls 
moyens sont soit d'avoir un téléphone rooté, autrement dit où l'on a tous les accès afin de changer le bon 
fichier de configuration. Soit d'avoir un téléphone de la marque Motorola, qui intègre le changement de ces 
mots directement dans son firmware. C'est pourquoi pour activer la reconnaissance vocale, nous sommes obligés 
de prononcer les mots « OK Google ».
	
	\subsection{Activation de la reconnaissance vocale}
	
Afin de pouvoir démarrer et utiliser la reconnaissance vocale, il faut un ensemble d'éléments :
\begin{itemize}
 \item Autovoice
 \item Tasker
\end{itemize}

Autovoice est une application Android qui permet d'utiliser la reconnaissance vocale de Google, et de se 
servir de la chaîne de caractères reconnues pour en faire ce que l'on souhaite. Par ailleurs, on peut la 
paramétrer de telle sorte qu'elle réagise seulement si une suite de mots clefs est reconnue. Afin de pouvoir 
communiquer avec Jarvis, le seul mot clef choisi a donc été son nom. Du côté de Tasker, c'est une application 
d'automatisation très connue sur Android. Elle permet de réaliser des tâches en réponse à un événement donné. 
Ainsi il est possible d'utiliser comme événement Autovoice, et comme tâche, une application qui permet de 
traiter la chaîne de caractères : SpeechRecognition.

	\subsection{SpeechRecognition}
	
SpeechRecognition (SP) est une application Android qui permet donc d'interpréter une chaîne de caractères, et 
d'envoyer une trame suivant le protocole SDCP au bon objet connecté. l'application possède deux bases de 
données. La première possède l'ensemble des objets intelligents. Cette base de données est stockée dans un 
fichier JSON.

\begin{lstlisting}[caption=Base de données des objets intelligents][frame=single]
{
    "smartDevices" : [
      {
        "device": {
          "idAction": "0x111",
          "bleName": "sdc_Lisa"
        }
      }]
}
\end{lstlisting}

Cette base de données comprend une liste des objets connectés proches de nous. Comme on peut le voir un objet 
est caractérisé par deux choses : l'identifiant de l'action qu'il peut réaliser, ainsi que le nom de l'objet 
bluetooth auquel il faut se connecter pour réaliser l'action.

\begin{lstlisting}[caption=Base de données des commandes vocales][frame=single]
{
    "voiceCommands" : [
      {
        "command" : {
            "voiceActivation" : "Quelle est la température",
            "voiceDiction" : "la température est",
            "idAction" : "0x111"
        }
      }]
}
\end{lstlisting}

Ainsi une commande vocale est caractérisée par une chaîne de caractères à reconnaître, une chaîne de 
caractères à dire par synthèse vocale, afin de donner un feedback sur ce qu'il se passe à l'utilisateur. Elle 
contient elle aussi l'identifiant de l'action à réaliser, afin de faire le lien avec l'autre base de données.

La première chose à faire après avoir reçue la phrase reconnue par la reconnaissance vocale, est de 
reconnaître quelle requête l'utilisateur souhaite réaliser. Pour ce faire, l'application réalise un algorithme 
sur la chaîne reçue, dont le but est d'évaluer la similarité avec l'ensemble des 
phrases possibles. La distance minimale caractérisera la requête faite par l'utilisateur. Il existe 
différents algorithmes, tel que: Levenshtein, ou JaroWinkler.

\paragraph{La distance de Levenshtein}est la plus simple. Celle-ci calcule le nombre de différences 
qu'il y a entre deux chaînes de caractères. Ces différences peuvent être le remplacement, la suppression, ou 
l'insertion d'un caractère.

\paragraph{La distance de JaroWinkler} part de la distance de Jaro dont l'équation est:
\begin{equation}
 d = \frac{1}{3}(\frac{m}{|s1|}+\frac{m}{|s2|}+\frac{m-t}{m})
\end{equation}

où :
\begin{itemize}
 \item $|s_i|$ est la longueur de la chaîne de caractères de la chaîne 'i'
 \item $m$ est le nombre de caractères \emph{correspondants} dans les 2 chaînes
 \item $t$ est le nombre de \emph{transpositions} nécessaires de ces caractères partagés
\end{itemize}

Deux caractères identiques de $s_1$ et $s_2$ sont dit \emph{correspondants} lorsque leur éloignement dans 
leur chaine respective ne dépasse pas :
\begin{equation}
 \lfloor{\frac{max(|s_1|, |s_2|)}{2}}\rfloor - 1
\end{equation}

Le nombre de \emph{transpositions} est obtenu en comparant le i-ème caractère \emph{correspondant} de $s_1$ 
avec le i-ème caractère \emph{correspondant} de $s_2$. Le nombre de fois où ces caractères sont différents, 
divisé par deux, donne le nombre de transpositions.

puis on calcule la distance avec cette équation :
\begin{equation}
 d_w = d_j + (l_p(1-d_j))
\end{equation}

avec :
\begin{itemize}
 \item $d_j$, la distance de Jaro entre $s_1$ et $s_2$
 \item $l$, la longueur du préfixe commun (avec un maximum de 4 caractères)
 \item $p$, un coefficient qui permet de favoriser les chaînes avec un préfixe commun. Winkler propose 
pour valeur $p=0.1$.

\end{itemize}

Wikipédia donne un très bon exemple pour comprendre cette distance. Ils appliquent cette algorithme pour 
calculer la distance entre MARTHA et MARHTA. Pour cela ils dressent un tableau :

\begin{tabular}{|0|1|2|3|4|5|6}
  \hline
   & M & A & R & T & H & A \\
  \hline
  M & 1 & 0 & 0 & 0 & 0 & 0 \\
  \hline
  A & 0 & 1 & 0 & 0 & 0 & 0 \\
  \hline
  R & 0 & 0 & 1 & 0 & 0 & 0 \\
  \hline
  H & 0 & 0 & 0 & 0 & \textbf{1} & 0 \\
  \hline
  T & 0 & 0 & 0 & \textbf{1} & 0 & 0 \\
  \hline
  A & 0 & 0 & 0 & 0 & 0 & 1 \\
\end{tabular}

On a 
\begin{itemize}
  \item $m = 6$ (Nombre de 1 dans la matrice)
  \item $|s_1| = 6$ 
  \item $|s_2| = 6$
  \item Les caractères correspondants sont \{{M,A,R,T,H,A\} pour $s_{1}$ et {M,A,R,H,T,A} pour $s_{2}$. En 
considérant ces ensembles ordonnés, on a donc 2 couples (T/H et H/T) de caractères \emph{correspondants} 
différents, soit deux demi-transpositions. D'où $t=\frac {2}{2}=1$
\end{itemize}



Afin de savoir quelle distance est la plus appropriée, une série de tests a été réalisée, en utilisant à 
chaque fois les 3 algorithmes. Le test consiste à prendre plusieurs phrases présentes dans le fichier des 
commandes vocales, et à les dire un grand nombres de fois, avec différents tons de voix, différentes 
articulations, et différents volumes. Ensuite, pour chaque requête, une liste des différentes phrases 
comprises par la reconnaissance vocale est établie. Les trois algorithmes sont alors appliqués, pour voir 
lequel est le plus robuste, et nous donne la correspondance la plus grande entre la requête souhaitée, et les 
commandes comprises. Il s'avère que l'algorithme le plus simple  était le plus robuste pour notre étude, 
c'est donc la la distance de Levenshtein qui a été gardée. 

Maintenant que nous sommes capables de savoir quelle requête l'utilisateur souhaite envoyer, et à quel objet, 
il faut savoir comment l'envoyer.

	\subsection{Intégration du protocole avec JNI}
Le protocole a été construit pour être sur systèmes embarqués, avec le langage C++. Or l'objet reconnaissance 
vocale doit lui aussi l'utiliser afin de pouvoir communiquer convenablement avec les autres objets. Ainsi deux 
choix étaient possibles :
\begin{itemize}
 \item Réécrire le protocole sous Android
 \item Intégrer le protocole en réalisant une interface pour Android
\end{itemize}

C'est la deuxième option qui a été choisie, celant évitant de refaire une grosse partie du travail déjà 
réalisée.

Il faut savoir que le système Android fonctionne grâce à une machine virtuelle Java : \emph{Art} (Pour 
Android Run Time). Cette machine n'éxécute de base à priori que du byte code Java, et non de l'assembleur que 
l'on pourrait obtenir en compilant un langage natif comme le C++. Grâce à \emph{JNI}, pour Java Native 
Interface, il est possible d'interfacer du code java, avec du code natif. Pour cela il suffit de compiler le 
code natif pour en faire une librairie, qu'il suffira se charger dans le programme. Dès lors il sera possible 
d'utiliser du code natif.


	\subsection{Communiquer avec les protocoles BLE et WiFi}
\section{Les actionneurs}
\section{Les capteurs}


